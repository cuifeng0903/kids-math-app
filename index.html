<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>はじめての たしざん・ひきざん ブロック（10×1）</title>

<!-- PWA（現状：単一HTML。manifest/SWは任意） -->
<link-touch-icon.png
manifest.webmanifest

<style>
:root{
  /* 動的に JS で計算して更新：必ず横10列が収まる */
  --block-size: 36px;       /* 1ユニットの一辺 */
  --gap: 6px;               /* ユニット間隔 */
  --group-border: 6px;      /* 10/20 まとまりの枠線太さ */
  --ring: #71c6ff;
  --flash: rgba(255,255,255,0.75);
  --text: #222;
  --muted: #6b7280;
  --brand: #6c5ce7;
  --bg: #f7f8fb;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: system-ui, -apple-system, "Segoe UI", "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Noto Sans JP", Meiryo, sans-serif;
  color:var(--text);
  background:var(--bg);
  text-align:center;
}
.wrap{max-width:960px;margin:0 auto;padding:10px 12px 60px}

h1{
  font-size: clamp(22px, 4.8vw, 40px);
  margin: 8px 0 4px;
  line-height:1.2;
}
#formula{
  font-size: clamp(20px, 4.2vw, 36px); /* 既知調整ポイント：上限拡大可 */
  font-weight: 800;
  margin: 6px 0 10px;
}

.toolbar{
  display:flex; flex-wrap:wrap; gap:8px 10px; align-items:center; justify-content:center;
  margin:8px 0 6px;
}
.toolbar .group{
  display:flex; flex-wrap:wrap; align-items:center; gap:6px 8px; background:#fff; border:1px solid #e5e7eb; border-radius:10px; padding:8px 10px;
}
label, select, input, button{font-size:16px}
input[type="number"]{width:5.5em; padding:6px 8px}
select{padding:6px 8px}
button{
  cursor:pointer; padding:8px 12px; border-radius:10px; border:1px solid #d1d5db; background:#fff;
}
button.primary{background:var(--brand); color:#fff; border-color:transparent}
button:disabled{opacity:.5; cursor:not-allowed}

.speed{
  display:flex; align-items:center; gap:8px
}
#speed{width:140px}

h4{margin: 14px 0 6px; color:#111; font-weight:700}
.board{
  /* 親は1カラム。各まとまりボックスが下に積み重なる */
  display:flex; flex-direction:column; align-items:center; gap:10px;
  width: min(92vw, 720px);
  margin: 0 auto 8px;
}
.groupBox{
  /* まとまり（10/20）ボックス：内側で横10列グリッド */
  --inner: calc(var(--block-size) * 10 + var(--gap) * 9);
  width: calc(var(--inner) + var(--group-border)*2 + var(--gap)*2);
  padding: calc(var(--gap));
  border-radius: 12px;
  border: var(--group-border) solid transparent;
  background:#fff;
}
.groupBox .grid{
  display:grid;
  grid-template-columns: repeat(10, var(--block-size));
  gap: var(--gap);
}
.group20{ background:#fffaf0; border-color:#ff9f1a }        /* 20：薄オレンジ＋太オレンジ枠 */
.group10{ background:#fff;    border-color:#ef4444 }        /* 10：白＋赤枠 */

.unit{
  width: var(--block-size); height: var(--block-size);
  border-radius: 8px;
  background:#fff; border:1px solid #e5e7eb;
}

/* 一桁（1〜9）の表示：枠なし・色で表現（まとまり外） */
.ones{
  width: calc(var(--block-size) * 10 + var(--gap) * 9);
}
.ones .grid{ display:grid; grid-template-columns: repeat(10, var(--block-size)); gap: var(--gap) }
.ones .unit{ border:none }

/* アニメーション用のオーバーレイレイヤー */
#animLayer{
  position: fixed; inset:0; pointer-events:none; z-index: 50;
}
.fly{
  position: fixed; width: var(--block-size); height: var(--block-size);
  border-radius: 8px; will-change: transform, opacity;
  transition: transform var(--dur) ease, opacity var(--dur) ease;
  box-shadow: 0 2px 6px rgba(0,0,0,.15);
  border:1px solid rgba(0,0,0,.08);
  background:#fff;
}

/* 紙吹雪（噴水）＋リング＋フラッシュ */
#fxLayer{ position: fixed; inset:0; pointer-events:none; z-index: 60 }
.confetti{ position:absolute; bottom: 18px; left:50%; width:8px; height:12px; border-radius:2px; opacity:.95; transform-origin:center bottom; }
@keyframes fountain {
  0% { transform: translate(-50%,0) rotate(0deg); opacity: 1 }
  100% { transform: translate(var(--dx), calc(var(--dy) * -1)) rotate(var(--rot)); opacity: 0 }
}
.ring{
  position:absolute; left:50%; bottom:20px; width:8px; height:8px; transform:translate(-50%,-50%);
  border: 3px solid var(--ring); border-radius:999px; opacity:0.7; animation: ring 900ms ease-out forwards;
}
@keyframes ring {
  from { transform: translate(-50%,-50%) scale(0.2); opacity: .8 }
  to   { transform: translate(-50%,-50%) scale(12);  opacity: 0 }
}
.flash{
  position:absolute; inset:0; background:var(--flash); animation: flash 420ms ease-out forwards;
}
@keyframes flash { from{opacity:0} 15%{opacity:1} to{opacity:0} }

/* スタンプ（終了時） */
#stamp{
  font-size: clamp(36px, 10vw, 84px);
  margin: 10px 0;
}

/* 補助 */
.note{ color:var(--muted); margin: 6px 0 14px }
footer{ color:var(--muted); font-size:13px; margin-top:18px }
</style>
</head>
<body>
<div class="wrap">
  <h1>はじめての たしざん・ひきざん ブロック</h1>
  <div id="formula">A ＋ B ＝ ？</div>

  <div class="toolbar">
    <div class="group">
      <label>演算
        <select id="op">
          <option value="+">＋（たす）</option>
          <option value="-">−（ひく）</option>
        </select>
      </label>
      <label>数A <input id="numA" type="number" min="0" value="13" /></label>
      <label>数B <input id="numB" type="number" min="0" value="7" /></label>
      <button id="play" class="primary">▶ 再生</button>
      <button id="reset">↺ リセット</button>
    </div>

    <div class="group">
      <div class="speed">
        <span>スピード</span>
        <input id="speed" type="range" min="0.5" max="2.0" value="1.0" step="0.1" />
        <span id="speedVal">x1.0</span>
      </div>
      <button id="sound" title="iOSは初回タップが必要">🔊 サウンド ON</button>
    </div>
  </div>

  <div class="toolbar">
    <div class="group">
      出題
      <select id="mode">
        <option value="add" selected>足し算のみ</option>
        <option value="sub">引き算のみ</option>
        <option value="mix">足し算と引き算</option>
      </select>
      難易度
      <select id="level">
        <option value="easy" selected>かんたん</option>
        <option value="normal">ふつう</option>
        <option value="hard">むずかしい</option>
      </select>
      <button id="start" class="primary">🏁 チャレンジ開始（5問）</button>
    </div>
  </div>

  <div class="toolbar">
    <div class="group">
      <input id="answer" inputmode="numeric" pattern="[0-9]*" placeholder="こたえ" />
      <button id="check" class="primary">✓ 確認</button>
      <button id="next">次へ ▶</button>
    </div>
  </div>

  <p id="status">正解 0/5</p>
  <p id="daily">今日: チャレンジ0回／正解0問</p>

  <!-- 縦並び：A → B → こたえ -->
  <h4>数A</h4>
  <div id="boardA" class="board"></div>

  <h4>数B</h4>
  <div id="boardB" class="board"></div>

  <h4>こたえ</h4>
  <div id="boardR" class="board"></div>

  <div id="stamp" aria-live="polite"></div>
  <div class="note">「再生」を押すとブロックが動きます。</div>

  <div id="animLayer"></div>
  <div id="fxLayer" aria-hidden="true"></div>

  <footer>© Kids Math — Single HTML build</footer>
</div>

<script>
/* =========================
   共通ユーティリティ
========================= */
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const fmt = (a,b,op,ans=null)=> `${a} ${op} ${b} ＝ ${ans===null?'？':ans}`;

function clamp(n,min,max){return Math.max(min,Math.min(max,n))}
function todayKey(){
  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth()+1).padStart(2,'0');
  const d = String(now.getDate()).padStart(2,'0');
  return `${y}-${m}-${d}`;
}

/* =========================
   レイアウト：横10列固定の自動縮小
========================= */
function adjustBlockSize(){
  // 3つのボードの実幅を測って最小値基準で調整（横スクロール無しを保証）
  const boards = [$('#boardA'), $('#boardB'), $('#boardR')];
  const widths = boards.map(b => b ? b.clientWidth : 0);
  const baseWidth = Math.max(240, Math.min(...widths.filter(w=>w>0)) || 320); // fallback
  // 内側に10ブロック＋9ギャップ＋左右の枠/パディング余白を見込む
  const gap = 6;           // px （初期）
  const border = 12;       // 6px ×2（左右）
  const pad = gap * 2;     // 左右パディング合計
  const s = Math.floor((baseWidth - (9*gap) - border - pad) / 10);
  const size = clamp(s, 14, 72);
  document.documentElement.style.setProperty('--gap', gap+'px');
  document.documentElement.style.setProperty('--block-size', size+'px');
  document.documentElement.style.setProperty('--group-border', '6px');
}
window.addEventListener('resize', adjustBlockSize);

/* =========================
   表示：まとまり＆色ルール
========================= */
const COLORS = {
  red:'#ef4444', orange:'#f59e0b', yellow:'#facc15', green:'#22c55e',
  sky:'#0ea5e9', purple:'#a855f7', lightPurple:'#d8b4fe', deepPink:'#e91e63',
  g1:'#d4d4d4', g2:'#9ca3af', g3:'#4b5563'
};

function makeUnit(color='#fff'){
  const d=document.createElement('div');
  d.className='unit';
  d.style.background=color;
  if (color!=='#fff') d.style.border='none';
  return d;
}
function makeGrid(units){
  const grid = document.createElement('div');
  grid.className='grid';
  units.forEach(u=>grid.appendChild(u));
  return grid;
}
function groupBox(kind, count=10){
  const box = document.createElement('div');
  box.className = 'groupBox ' + (kind===20?'group20':'group10');
  const units = Array.from({length:count},()=>makeUnit());
  box.appendChild(makeGrid(units));
  return box;
}
function onesBox(n){
  const box = document.createElement('div');
  box.className='ones';
  const units=[];
  if (n>=1 && n<=6){
    const map=[COLORS.red,COLORS.orange,COLORS.yellow,COLORS.green,COLORS.sky,COLORS.purple];
    for(let i=0;i<n;i++) units.push(makeUnit(map[n-1])); // 同色でn個
  }else if(n===7){
    [COLORS.red,COLORS.orange,COLORS.yellow,COLORS.green,COLORS.sky,COLORS.purple,COLORS.lightPurple]
      .forEach(c=>units.push(makeUnit(c)));
  }else if(n===8){
    for(let i=0;i<8;i++) units.push(makeUnit(COLORS.deepPink));
  }else if(n===9){
    for(let i=0;i<3;i++) units.push(makeUnit(COLORS.g1));
    for(let i=0;i<3;i++) units.push(makeUnit(COLORS.g2));
    for(let i=0;i<3;i++) units.push(makeUnit(COLORS.g3));
  }
  box.appendChild(makeGrid(units));
  return box;
}

/** n（>=0）を 20/10/1（≤9）ルールで描画 */
function drawNumber(board, n){
  board.innerHTML='';
  let rest = n;
  while(rest>=20){ board.appendChild(groupBox(20,20)); rest-=20 }
  while(rest>=10){ board.appendChild(groupBox(10,10)); rest-=10 }
  if(rest>0){ board.appendChild(onesBox(rest)) }
}

/** フラットな「ユニット数」を返す（アニメ用） */
function countUnits(n){ return n; }

/* =========================
   サウンド（WebAudio）
========================= */
const AC = new (window.AudioContext||window.webkitAudioContext)();
let soundOn = true;

function ensureAudio(){
  if (AC.state==='suspended') AC.resume().catch(()=>{});
}
function envGain(sec=0.18, peak=0.25){
  const g=AC.createGain();
  const now=AC.currentTime;
  g.gain.setValueAtTime(0,now);
  g.gain.linearRampToValueAtTime(peak, now+0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now+sec);
  return g;
}
function tone(freq=440, sec=0.18, type='sine'){
  const o=AC.createOscillator();
  o.type=type; o.frequency.value=freq;
  const g=envGain(sec);
  o.connect(g).connect(AC.destination);
  o.start(); o.stop(AC.currentTime+sec);
}
function sfx(type){
  if(!soundOn) return;
  ensureAudio();
  if(type==='whoosh'){
    const o=AC.createOscillator(), g=envGain(0.25,0.22);
    o.type='sawtooth'; o.frequency.setValueAtTime(220,AC.currentTime);
    o.frequency.exponentialRampToValueAtTime(660, AC.currentTime+0.25);
    o.connect(g).connect(AC.destination); o.start(); o.stop(AC.currentTime+0.26);
  }else if(type==='pop'){
    const o=AC.createOscillator(), g=envGain(0.12,0.3);
    o.type='square'; o.frequency.value=700;
    o.connect(g).connect(AC.destination); o.start(); o.stop(AC.currentTime+0.12);
  }else if(type==='chord'){
    [523.25,659.25,783.99].forEach((f,i)=>{
      const o=AC.createOscillator(), g=envGain(0.35,0.18);
      o.type='sine'; o.frequency.value=f;
      o.connect(g).connect(AC.destination);
      o.start(AC.currentTime+0.02*i); o.stop(AC.currentTime+0.35+0.02*i);
    });
  }
}

/* =========================
   紙吹雪（噴水）＋リング＋フラッシュ
========================= */
function celebrate(){
  const fx = $('#fxLayer'); fx.innerHTML='';
  // flash
  const flash = document.createElement('div'); flash.className='flash';
  fx.appendChild(flash);
  // ring
  const ring = document.createElement('div'); ring.className='ring'; fx.appendChild(ring);
  // confetti fountain
  const N=80;
  for(let i=0;i<N;i++){
    const c=document.createElement('div');
    c.className='confetti';
    const hue = Math.floor(Math.random()*360);
    c.style.background = `hsl(${hue} 95% 55%)`;
    const angle = (Math.random()*Math.PI/2) + Math.PI/4; // 45°〜135°
    const power = 140 + Math.random()*180;
    const dx = Math.cos(angle)*power; const dy = Math.sin(angle)*power;
    const rot = (Math.random()*720 - 360) + 'deg';
    c.style.setProperty('--dx', `${dx}px`);
    c.style.setProperty('--dy', `${dy}px`);
    c.style.setProperty('--rot', rot);
    const dur = (0.9 + Math.random()*0.8).toFixed(2)+'s';
    c.style.animation = `fountain ${dur} ease-out forwards`;
    fx.appendChild(c);
  }
}

/* =========================
   アニメーション（可視化）
========================= */
const animLayer = $('#animLayer');

function speedMul(){ return parseFloat($('#speed').value || '1'); }
function dur(ms){ return (ms / speedMul()) | 0; } // 速度 x2 → 時間 1/2

function rectOf(el){ return el.getBoundingClientRect(); }

function createFly(x,y,color='#fff'){
  const d=document.createElement('div');
  d.className='fly';
  d.style.left = (x)+'px';
  d.style.top = (y)+'px';
  d.style.background = color;
  d.style.setProperty('--dur', dur(380)+'ms');
  animLayer.appendChild(d);
  return d;
}

/** 結果ボード内の「n番目のユニット」座標（10列固定） */
function resultSlot(n){
  const br = rectOf($('#boardR'));
  const bs = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--block-size'));
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
  const col = n % 10;
  const row = Math.floor(n/10);
  const x = br.left + (bs + gap) * col + gap + 6; // 左padding相当
  const y = br.top  + (bs + gap) * row + gap + 6  + 24; // 多少下げる（まとまりbox内余白）
  return {x,y};
}

/** A→R, B→R 移動（加算） */
async function animateAdd(aCount, bCount){
  // A のユニットを順に結果へ
  await flyMany(aCount, 'A');
  await flyMany(bCount, 'B', aCount); // 既にaCountまで埋まっている
}

/** B末尾→A末尾へ飛来→相殺（減算） */
async function animateSub(aCount, bCount){
  // b回繰り返す（末尾から）
  for(let i=0;i<bCount;i++){
    // A末尾ユニットのスクリーン座標（おおよそ）
    const At = tailXY($('#boardA'));
    const Bt = tailXY($('#boardB'));
    // Bの末尾からA末尾へ飛ぶ
    const node = createFly(Bt.x,Bt.y,'#fff');
    await nextFrame();
    node.style.transform = `translate(${At.x-Bt.x}px, ${At.y-Bt.y}px)`;
    node.style.opacity = .6;
    sfx('whoosh');
    await wait(dur(420));
    node.remove();
    // 相殺ポップ
    sfx('pop');
    // 軽いフラッシュ演出（末尾近辺）
    bubbleAt(At.x, At.y);
  }
  // 残ったAを結果へ
  const rest = aCount - bCount;
  if (rest>0) await flyMany(rest, 'A');
}

function tailXY(board){
  // 末尾ユニットの概形座標（ざっくり右下終端）
  const r = rectOf(board);
  const bs = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--block-size'));
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
  // 1行10個の右端位置
  const colX = r.left + (bs+gap)*9 + gap + 6;
  // 概算：ユニット数から行数を出せないので、ボード矩形の下端を採用
  const y = r.bottom - (bs/2 + 16);
  return {x: colX, y};
}

function bubbleAt(x,y){
  const d=document.createElement('div');
  d.className='flash';
  d.style.inset='unset';
  d.style.left=(x-24)+'px'; d.style.top=(y-24)+'px';
  d.style.width='48px'; d.style.height='48px'; d.style.borderRadius='999px';
  $('#fxLayer').appendChild(d);
  setTimeout(()=>d.remove(),420);
}

/** n個のフライングユニットを結果へ（offset は既に詰まっている個数） */
async function flyMany(n, from, offset=0){
  for(let i=0;i<n;i++){
    const src = from==='A' ? $('#boardA') : $('#boardB');
    const p = tailXY(src);            // 末尾付近から出す演出（簡易）
    const node = createFly(p.x,p.y,'#fff');
    await nextFrame();
    const tgt = resultSlot(offset+i);
    node.style.transform = `translate(${tgt.x - p.x}px, ${tgt.y - p.y}px)`;
    sfx('whoosh');
    await wait(dur(380));
    node.remove();
  }
}

function nextFrame(){ return new Promise(r=>requestAnimationFrame(()=>r())) }
function wait(ms){ return new Promise(r=>setTimeout(r, ms)) }

/* =========================
   入力・UI・表示制御
========================= */
const opSel = $('#op');
const inA = $('#numA');
const inB = $('#numB');
const playBtn = $('#play');
const resetBtn = $('#reset');
const speed = $('#speed');
const speedVal = $('#speedVal');
const soundBtn = $('#sound');

const ans = $('#answer');
const checkBtn = $('#check');
const nextBtn = $('#next');

const boardA = $('#boardA');
const boardB = $('#boardB');
const boardR = $('#boardR');
const formula = $('#formula');
const statusEl = $('#status');
const dailyEl = $('#daily');
const stampEl = $('#stamp');

function sanitizeNumberInput(e){
  // -, +, e/E をブロック、非数字は除去
  const bad = ['-','+','e','E'];
  if (e.type==='keydown' && bad.includes(e.key)) e.preventDefault();
  if (e.type==='input'){
    const v = e.target.value.replace(/[^0-9]/g,'');
    if (v!==e.target.value) e.target.value=v;
  }
}
['keydown','input'].forEach(t=>{
  ans.addEventListener(t, sanitizeNumberInput);
});
['input'].forEach(t=>{
  inA.addEventListener(t, ()=>{ if(challenge.active) return; inA.value = inA.value.replace(/[^0-9]/g,'') });
  inB.addEventListener(t, ()=>{ if(challenge.active) return; inB.value = inB.value.replace(/[^0-9]/g,'') });
});

soundBtn.addEventListener('click',()=>{
  soundOn = !soundOn;
  ensureAudio();
  soundBtn.textContent = soundOn ? '🔊 サウンド ON' : '🔇 サウンド OFF';
});

speed.addEventListener('input',()=>{
  speedVal.textContent = 'x' + parseFloat(speed.value).toFixed(1);
});

function refreshBoards(){
  const a = parseInt(inA.value||'0',10);
  const b = parseInt(inB.value||'0',10);
  drawNumber(boardA, a);
  drawNumber(boardB, b);
  boardR.innerHTML='';
  formula.textContent = fmt(a,b,opSel.value);
  adjustBlockSize();
}

opSel.addEventListener('change', refreshBoards);
inA.addEventListener('change', refreshBoards);
inB.addEventListener('change', refreshBoards);
window.addEventListener('load', ()=>{ refreshBoards(); loadDaily() });

resetBtn.addEventListener('click', ()=>{
  animLayer.innerHTML=''; $('#fxLayer').innerHTML='';
  refreshBoards(); stampEl.textContent='';
});

playBtn.addEventListener('click', async ()=>{
  if(playBtn.disabled) return;
  playBtn.disabled = true; resetFx();
  const a = parseInt(inA.value||'0',10);
  const b = parseInt(inB.value||'0',10);
  const op = opSel.value;
  boardR.innerHTML='';
  if (op==='+'){
    await animateAdd(countUnits(a), countUnits(b));
    drawNumber(boardR, a+b);
  }else{
    const A = Math.max(a,b), B = Math.min(a,b);
    if (A!==a){ inA.value=A; inB.value=B; refreshBoards(); }
    await animateSub(A, B);
    drawNumber(boardR, A-B);
  }
  formula.textContent = fmt(parseInt(inA.value,10), parseInt(inB.value,10), opSel.value, opSel.value==='+'? (parseInt(inA.value,10)+parseInt(inB.value,10)) : (parseInt(inA.value,10)-parseInt(inB.value,10)));
  // 左右は復元（元々変更していない）
  await wait(dur(160));
  playBtn.disabled = false;
});

/* =========================
   チャレンジ（5問固定）
========================= */
const modeSel = $('#mode');
const levelSel = $('#level');
const startBtn = $('#start');

const challenge = {
  active:false, list:[], idx:0, correct:0, total:5, answered:false
};

function rangeByLevel(){
  const lv = levelSel.value;
  if(lv==='easy')   return {A:[1,5],  B:[1,5]};
  if(lv==='normal') return {A:[5,10], B:[1,5]};
  return {A:[1,19], B:[1,10]}; // hard
}
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min }

function makeProblems(){
  const problems=[];
  const seen = new Set();
  const {A:[a1,a2], B:[b1,b2]} = rangeByLevel();
  while(problems.length<challenge.total){
    const op = modeSel.value==='add' ? '+' : modeSel.value==='sub' ? '-' : (Math.random()<0.5?'+':'-');
    let A = randInt(a1,a2), B = randInt(b1,b2);
    if (op==='-' && A<B) [A,B] = [B,A]; // A≥B
    const key = (op==='+')
      ? `add:${Math.min(A,B)}_${Math.max(A,B)}`
      : `sub:${A}_${B}`;
    if(seen.has(key)) continue;
    seen.add(key);
    problems.push({op,A,B});
  }
  return problems;
}

function lockChallengeUI(lock){
  modeSel.disabled = lock; levelSel.disabled = lock;
  inA.disabled = lock; inB.disabled = lock; opSel.disabled = lock;
}

function showProblem(){
  const {op,A,B} = challenge.list[challenge.idx];
  opSel.value=op; inA.value=A; inB.value=B;
  formula.textContent = fmt(A,B,op);
  drawNumber(boardA, A);
  drawNumber(boardB, B);
  boardR.innerHTML='';
  ans.value='';
  challenge.answered=false;
  adjustBlockSize();
  statusEl.textContent = `正解 ${challenge.correct}/${challenge.total}`;
  stampEl.textContent='';
}

startBtn.addEventListener('click', ()=>{
  if(challenge.active) return;
  challenge.active=true; challenge.list=makeProblems(); challenge.idx=0; challenge.correct=0;
  lockChallengeUI(true);
  incDaily('challenge',1);
  showProblem();
});

checkBtn.addEventListener('click', async ()=>{
  if(!challenge.active) { // 単発モードでも動く
    const ok = evaluateOnce();
    if(ok) { sfx('chord'); celebrate(); await runAndAutoNext(false); }
    return;
  }
  if(challenge.answered) return;
  const ok = evaluateOnce();
  challenge.answered = true;
  if(ok){
    challenge.correct++;
    sfx('chord'); celebrate();
    await runAndAutoNext(true);
  }else{
    // 不正解：祝エフェクトなし。アニメはいつでも可（ここでは自動では再生しない）
  }
  statusEl.textContent = `正解 ${challenge.correct}/${challenge.total}`;
});

nextBtn.addEventListener('click', ()=>{
  if(!challenge.active) return;
  stepNext();
});

async function runAndAutoNext(isChallenge){
  // 可視化アニメを自動再生 → 3秒後に次へ
  await playVisualizationOnce();
  await wait(3000);
  if(isChallenge) stepNext();
}

function stepNext(){
  challenge.idx++;
  if(challenge.idx >= challenge.total){
    // 終了
    finishChallenge();
  }else{
    showProblem();
  }
}

function finishChallenge(){
  challenge.active=false;
  lockChallengeUI(false);
  addDailyCorrect(challenge.correct);
  statusEl.textContent = `正解 ${challenge.correct}/${challenge.total}`;
  if(challenge.correct>=3){
    stampEl.textContent = '🥇 ' + randomStamp();
  }else{
    stampEl.textContent = '📘 またちょうせんしてみよう！';
  }
  saveDaily(); loadDaily();
}

function randomStamp(){
  const list = [
    '🍎','🍊','🍋','🍉','🍇','🍓','🍒','🍑','🍌','🍍',
    '🐶','🐱','🐭','🐹','🐰','🦊','🐻','🐼','🐨','🐯',
    '🦁','🐮','🐷','🐸','🐵','🐔','🐧','🦄','🦓','🐙'
  ];
  return list[Math.floor(Math.random()*list.length)];
}

function evaluateOnce(){
  const A = parseInt(inA.value||'0',10);
  const B = parseInt(inB.value||'0',10);
  const op = opSel.value;
  const expected = op==='+'? A+B : A>=B ? A-B : (B-A); // 引き算は常にA≥Bで判定
  const given = parseInt(ans.value||'NaN',10);
  return Number.isFinite(given) && given===expected;
}

async function playVisualizationOnce(){
  playBtn.disabled=true;
  const A = parseInt(inA.value||'0',10);
  const B = parseInt(inB.value||'0',10);
  const op = opSel.value;
  boardR.innerHTML='';
  if(op==='+'){
    await animateAdd(A,B);
    drawNumber(boardR, A+B);
  }else{
    const a=Math.max(A,B), b=Math.min(A,B);
    if(a!==A){ inA.value=a; inB.value=b; drawNumber(boardA,a); drawNumber(boardB,b); }
    await animateSub(a,b);
    drawNumber(boardR, a-b);
  }
  formula.textContent = fmt(parseInt(inA.value,10), parseInt(inB.value,10), op, op==='+' ? (parseInt(inA.value,10)+parseInt(inB.value,10)) : (parseInt(inA.value,10)-parseInt(inB.value,10)));
  await wait(dur(160));
  playBtn.disabled=false;
}

function resetFx(){ $('#fxLayer').innerHTML=''; }

/* =========================
   日別記録（localStorage）
   形式：{ [yyyy-mm-dd]: {challenge:number, correct:number} }
========================= */
const STORE_KEY = 'kids_math_daily';

function loadDaily(){
  try{
    const map = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');
    const key = todayKey();
    const val = map[key] || {challenge:0, correct:0};
    dailyEl.textContent = `今日: チャレンジ${val.challenge}回／正解${val.correct}問`;
  }catch(e){ /* noop */ }
}
function saveDaily(map){
  localStorage.setItem(STORE_KEY, JSON.stringify(map));
}
function incDaily(field, inc){
  const map = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');
  const key = todayKey();
  if(!map[key]) map[key]={challenge:0, correct:0};
  map[key][field] = (map[key][field]||0) + inc;
  saveDaily(map); loadDaily();
}
function addDailyCorrect(n){
  const map = JSON.parse(localStorage.getItem(STORE_KEY) || '{}');
  const key = todayKey();
  if(!map[key]) map[key]={challenge:0, correct:0};
  map[key].correct = (map[key].correct||0) + n;
  saveDaily(map); loadDaily();
}

/* =========================
   起動
========================= */
window.addEventListener('load', ()=>{
  adjustBlockSize();
  // 初期式
  formula.textContent = fmt(parseInt(inA.value,10), parseInt(inB.value,10), opSel.value);
});
</script>
</body>
</html>
