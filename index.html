<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<!-- iPhone/iPad 最適化 + PWAアイコン設定 -->
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="theme-color" content="#6c5ce7" />
<!-- PWA: 画像を置いたらホーム画面にアイコンが出ます -->
icons/apple-touch-icon.png
manifest.webmanifest

<title>はじめての たしざん・ひきざん ブロック（10×1 & ステージ／最終版）</title>
<style>
  :root{
    --bg:#f7f8fb; --panel:#ffffff; --text:#1f2a44; --muted:#6b7280; --accent:#6c5ce7;
    --gap:10px; --block-size:64px; --dur:600ms;

    /* 一桁の色 */
    --c-red:#ef4444; --c-orange:#f59e0b; --c-yellow:#facc15; --c-green:#22c55e;
    --c-aqua:#38bdf8; --c-purple:#a855f7; --c-lilac:#c084fc; --c-hotpink:#e91e63;
    --c-gray:#9ca3af;            /* 標準の灰 */
    --c-gray-light:#e5e7eb;      /* 薄い灰 */
    --c-gray-dark:#6b7280;       /* 濃い灰 */

    /* まとまり（10/20） */
    --ten-border:#ef4444;   --ten-bg:#ffffff;
    --twenty-border:#f59e0b;--twenty-bg:#fffaf0;

    /* 祝エフェクト */
    --flash:#fff6;

    /* 全体縮小（JSで計算して適用） */
    --app-scale: 1;
  }
  *{box-sizing:border-box}
  html, body { height: 100%; }
  body{
    margin:0; background:var(--bg); color:var(--text);
    font-family: ui-rounded, system-ui, -apple-system, "Segoe UI", "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
    /* 画面内に収めるため、基本はスクロールしない */
    overflow: hidden;
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    padding-bottom: env(safe-area-inset-bottom);
  }

  /* ★ 全体をスケールして画面に収める */
  #app{
    transform: scale(var(--app-scale));
    transform-origin: top left;
    width: 100%;
  }

  header{
    padding:16px calc(20px + env(safe-area-inset-right)) 16px calc(20px + env(safe-area-inset-left));
    background:linear-gradient(90deg, var(--accent), #8e79ff);
    color:white; position:sticky; top:0; z-index:10;
  }
  header h1{ margin:0; font-size: clamp(18px, 3.5vw, 22px); }
  main{ max-width:1100px; margin:20px auto; padding:0 16px; }
  .card{
    background:var(--panel); border-radius:14px; box-shadow:0 8px 24px rgba(31,42,68,.08);
    padding:16px;
  }
  .controls{ display:grid; gap:12px; grid-template-columns:1fr; }
  .row{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
  .row > * { flex:0 0 auto; }
  label{ font-size:14px; color:var(--muted); }
  input[type="number"]{
    width:110px; padding:10px 12px; border:1px solid #e5e7eb; border-radius:10px; font-size:20px; text-align:center;
  }
  select{
    padding:10px 12px; border:1px solid #e5e7eb; border-radius:10px; font-size:18px;
  }
  button{
    border:0; border-radius:999px; padding:12px 16px; font-size:16px; background:#ecebff; color:#3e2cff;
    cursor:pointer; transition:.15s transform, .15s filter; font-weight:600; -webkit-tap-highlight-color: transparent;
  }
  button.primary{ background:#3e2cff; color:white; }
  button:disabled{ filter:grayscale(.8); opacity:.6; cursor:not-allowed; }
  .speed{ display:flex; align-items:center; gap:10px; color:var(--muted); }
  input[type="range"]{ width:180px; }

  .workspace{
    margin-top:16px; padding:14px; border:1px dashed #d1d5db; border-radius:12px; background:#fcfdff;
    position:relative; overflow:clip;
  }

  /* ★ 式のフォントを大きく（上限を拡大） */
  .equation{
    font-size: clamp(26px, 6vw, 48px);
    display:flex; align-items:center; gap:16px; justify-content:center; margin-bottom:12px;
  }
  .eq-num{ min-width:48px; text-align:center; font-weight:800; }
  .eq-op, .eq-eq{ opacity:.75; font-weight:800; }

  /* 縦並び（数A → 数B → こたえ） */
  .boards{
    display:grid; grid-template-columns: 1fr; gap:14px;
    align-items:start; justify-items:stretch;
  }
  .board{ width:100%; background:white; border:1px solid #edf2f7; border-radius:12px; padding:10px; }
  .board h3{ margin:0 0 8px; font-size:14px; color:var(--muted); text-align:left; }

  /* 横10列固定・自動縮小（横スクロールなし） */
  .blocks{
    display:grid;
    grid-template-columns: repeat(10, var(--block-size));
    grid-auto-rows: var(--block-size);
    gap: var(--gap);
    justify-content:flex-start; align-content:start; width:100%;
  }

  /* ユニット（小ブロック＝値1） */
  .block{
    width:var(--block-size); height:var(--block-size);
    border-radius:12px; box-shadow:0 3px 8px rgba(0,0,0,.08); position:relative;
  }
  /* 20：薄オレンジ＋太オレンジ枠（1×20で20を表現） */
  .block.twentyu{ background:var(--twenty-bg); border:6px solid var(--twenty-border); }
  /* 10：白＋赤枠（枠線太さを20と同じ6px） */
  .block.tenu{ background:var(--ten-bg); border:6px solid var(--ten-border); }

  /* 一桁色 */
  .c-red{ background: var(--c-red); } .c-orange{ background: var(--c-orange); } .c-yellow{ background: var(--c-yellow); }
  .c-green{ background: var(--c-green); } .c-aqua{ background: var(--c-aqua); } .c-purple{ background: var(--c-purple); }
  .c-lilac{ background: var(--c-lilac); } .c-hotpink{ background: var(--c-hotpink); }
  .c-gray{ background: var(--c-gray); }             /* 標準の灰 */
  .c-graylight{ background: var(--c-gray-light); } /* 薄い灰 */
  .c-graydark{ background: var(--c-gray-dark); }   /* 濃い灰 */

  .hint{ margin-top:10px; color:var(--muted); font-size:14px; text-align:center; }

  /* 飛行クローン・消滅 */
  .fly-clone{
    position:fixed; z-index:9999; border-radius:12px; box-shadow:0 3px 10px rgba(0,0,0,.2);
    will-change: transform, opacity;
  }
  .poof{ animation: poof .35s ease forwards; }
  @keyframes poof{ 0% { transform: scale(1); opacity:1; } 100%{ transform: scale(.3); opacity:0; filter: blur(1px); } }
  .cross{ position:relative; overflow:hidden; }
  .cross::before, .cross::after{
    content:""; position:absolute; left:8px; right:8px; height:6px; background:rgba(255,255,255,.9); top:calc(50% - 3px);
    border-radius:6px; transform:rotate(45deg);
  }
  .cross::after{ transform:rotate(-45deg); }

  /* チャレンジ UI */
  .challenge-bar{
    display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin-top:8px;
    border-top:1px dashed #e5e7eb; padding-top:10px;
  }
  .progress{ display:flex; gap:6px; align-items:center; }
  .dot{
    width:18px; height:18px; border-radius:50%;
    background:#e5e7eb; border:2px solid #c7c9d1;
  }
  .dot.done{ background:#22c55e; border-color:#16a34a; }
  .dot.fail{ background:#ef4444; border-color:#dc2626; }
  .score{ color:var(--muted); font-weight:700; }
  .ans-area{ display:flex; align-items:center; gap:8px; }
  #ansInput{ width:110px; padding:8px 10px; border:1px solid #e5e7eb; border-radius:10px; font-size:18px; text-align:center; }
  #checkMsg{ min-width:110px; font-weight:800; letter-spacing:.02em; }
  #dailyStats{ color:var(--muted); font-size:13px; margin-left:auto; }

  .hidden{ display:none !important; }

  /* 祝エフェクト（噴水型：下部中央→上へ） */
  .celebrate{ position:fixed; inset:0; pointer-events:none; overflow:hidden; z-index:9998; }
  .confetti{
    position:fixed; bottom:0; left:50vw;
    width:10px; height:14px; opacity:0.95; border-radius:2px;
    animation: confetti-up 1s ease-out forwards;
  }
  @keyframes confetti-up{
    0%   { transform: translate(0, 0) rotate(0deg);   opacity:0.95; }
    100% { transform: translate(var(--dx, 0vw), -70vh) rotate(720deg); opacity:0; }
  }
  .pulse{ position:absolute; inset:0; pointer-events:none; z-index:9997; }
  .pulse::before{
    content:""; position:absolute; left:50%; top:50%; width:20vmin; height:20vmin;
    border-radius:50%; transform: translate(-50%,-50%);
    background: radial-gradient(circle, #fff7 0%, transparent 60%);
    animation: pulse-ring 900ms ease-out forwards;
  }
  @keyframes pulse-ring{
    0% { transform: translate(-50%,-50%) scale(.6); opacity:.9; }
    100%{ transform: translate(-50%,-50%) scale(2.4); opacity:0; }
  }
  .flash{ position:absolute; inset:0; background: var(--flash); animation: flashout 300ms ease-out forwards; }
  @keyframes flashout{ from{ opacity:1; } to{ opacity:0; } }

  @media (max-width:740px){
    :root{ --block-size:52px; --gap:8px; }
  }
</style>
</head>
<body>
<!-- ★ 全体スケーリング対象のラッパー -->
<div id="app">
  <header>
    <h1>はじめての たしざん・ひきざん ブロック（10×1 & ステージ／最終版）</h1>
  </header>
  <main>
    <section class="card controls" aria-label="コントロール">
      <div class="row" id="basicControls">
        <label>演算</label>
        <select id="op" aria-label="演算を選択">
          <option value="+">＋（たす）</option>
          <option value="-">−（ひく）</option>
        </select>

        <label>数A</label>
        <input id="a" type="number" min="0" max="99" value="13" inputmode="numeric" pattern="[0-9]*" />

        <label>数B</label>
        <input id="b" type="number" min="0" max="99" value="7" inputmode="numeric" pattern="[0-9]*" />

        <button id="play" class="primary">▶ 再生</button>
        <button id="reset">↺ リセット</button>
        <button id="random">🎲 ランダム</button>

        <div class="speed">
          <span>スピード</span>
          <input id="speed" type="range" min="0.5" max="2.0" step="0.25" value="1.0" />
          <span id="speedLabel">x1.0</span>
        </div>

        <button id="soundToggle">🔊 サウンド ON</button>
      </div>

      <div class="challenge-bar">
        <label for="modeSel">出題</label>
        <select id="modeSel" aria-label="チャレンジ出題モード">
          <option value="plus" selected>足し算のみ</option>
          <option value="minus">引き算のみ</option>
          <option value="mixed">足し算と引き算</option>
        </select>

        <label for="levelSel">難易度</label>
        <select id="levelSel" aria-label="難易度">
          <option value="easy" selected>かんたん</option>
          <option value="normal">ふつう</option>
          <option value="hard">むずかしい</option>
        </select>

        <button id="startChallenge">🏁 チャレンジ開始（5問）</button>
        <div class="ans-area hidden" id="ansArea">
          <label for="ansInput">こたえ</label>
          <input id="ansInput" type="number" inputmode="numeric" pattern="[0-9]*" min="0" />
          <button id="checkAnswer">✓ 確認</button>
          <span id="checkMsg"></span>
          <button id="nextQ" class="hidden">次へ ▶</button>
        </div>
        <div class="progress" id="progress"></div>
        <div class="score" id="score">正解 0/5</div>
        <div id="dailyStats">今日: チャレンジ0回 / 正解0問</div>
        <button id="endChallenge" class="hidden">終了</button>
      </div>
    </section>

    <section class="card workspace" aria-label="ブロックのワークスペース" id="workspace">
      <div class="equation" aria-live="polite">
        <span class="eq-num" id="eqA">13</span>
        <span class="eq-op" id="eqOp">−</span>
        <span class="eq-num" id="eqB">7</span>
        <span class="eq-eq">＝</span>
        <span class="eq-num" id="eqAns">？</span>
      </div>

      <!-- 縦並び：数A → 数B → こたえ -->
      <div class="boards" id="boards">
        <div class="board" aria-label="数Aのブロック">
          <h3>数A</h3>
          <div class="blocks" id="left"></div>
        </div>

        <div class="board" aria-label="数Bのブロック">
          <h3>数B</h3>
          <div class="blocks" id="right"></div>
        </div>

        <div class="board" aria-label="こたえのブロック">
          <h3>こたえ</h3>
          <div class="blocks" id="result"></div>
        </div>
      </div>

      <div class="hint" id="hint">「再生」を押すとブロックが動きます。</div>
    </section>
  </main>
</div>

<!-- 祝オーバーレイ（紙吹雪・リング・フラッシュ） -->
<div id="celebrate" class="celebrate hidden"></div>

<script>
(() => {
  const qs = s => document.querySelector(s);

  const el = {
    app: qs('#app'),
    op: qs('#op'), a: qs('#a'), b: qs('#b'),
    left: qs('#left'), right: qs('#right'), result: qs('#result'),
    eqA: qs('#eqA'), eqB: qs('#eqB'), eqOp: qs('#eqOp'), eqAns: qs('#eqAns'),
    hint: qs('#hint'), workspace: qs('#workspace'),
    play: qs('#play'), reset: qs('#reset'), random: qs('#random'),
    speed: qs('#speed'), speedLabel: qs('#speedLabel'),
    soundToggle: qs('#soundToggle'),

    // チャレンジ
    modeSel: qs('#modeSel'), levelSel: qs('#levelSel'),
    startCh: qs('#startChallenge'), endCh: qs('#endChallenge'),
    ansArea: qs('#ansArea'), ansInput: qs('#ansInput'),
    checkBtn: qs('#checkAnswer'), checkMsg: qs('#checkMsg'),
    nextQ: qs('#nextQ'), progress: qs('#progress'), score: qs('#score'),
    dailyStats: qs('#dailyStats'),

    // 基本UI
    basicControls: qs('#basicControls'),

    // 祝
    celebrate: qs('#celebrate'),
  };

  /* ========= スケール調整（全体を画面に収める） ========= */
  function fitToViewport(){
    const app = el.app;
    if (!app) return;
    // 一旦等倍
    document.documentElement.style.setProperty('--app-scale', '1');
    const vw = window.innerWidth, vh = window.innerHeight;

    // appの実サイズを測る
    const rect = app.getBoundingClientRect();
    // スクロールを仮に解除して実高さを推定
    const fullH = app.scrollHeight;
    const fullW = app.scrollWidth;

    let scale = 1.0;
    if (fullH > vh) scale = Math.max(0.6, vh / fullH);  // 高さ基準
    // 幅も収まるよう調整
    if (fullW * scale > vw) {
      scale = Math.max(0.6, scale * (vw / (fullW * scale)));
    }
    document.documentElement.style.setProperty('--app-scale', scale.toFixed(3));
  }

  /* ========= 共通ユーティリティ ========= */
  let animating = false;
  let speedMul = parseFloat(el.speed.value || '1');
  let autoTimer = null; // 自動遷移タイマー（正解時のみ）
  const clamp = (v, lo, hi) => Math.min(Math.max(v, lo), hi);
  const ms = (base) => base / speedMul;

  function updateEq(a, b, op, ans=null){
    el.eqA.textContent = a;
    el.eqB.textContent = b;
    el.eqOp.textContent = (op === '+') ? '＋' : '−';
    el.eqAns.textContent = (ans === null ? '？' : ans);
  }
  function setDisabled(dis){
    [el.op, el.a, el.b, el.random, el.reset].forEach(x=> x.disabled = dis);
    el.play.disabled = dis;
  }
  function clearBlocks(){ el.left.innerHTML=''; el.right.innerHTML=''; el.result.innerHTML=''; }

  /* ========= 一桁色配列 ========= */
  const COLOR_CLASS = {
    red:'c-red', orange:'c-orange', yellow:'c-yellow',
    green:'c-green', aqua:'c-aqua', purple:'c-purple',
    lilac:'c-lilac', hotpink:'c-hotpink',
    gray:'c-gray', graylight:'c-graylight', graydark:'c-graydark'
  };
  function onesColors(k){
    switch(k){
      case 0: return [];
      case 1: return [COLOR_CLASS.red];
      case 2: return [COLOR_CLASS.orange, COLOR_CLASS.orange];
      case 3: return [COLOR_CLASS.yellow, COLOR_CLASS.yellow, COLOR_CLASS.yellow];
      case 4: return Array(4).fill(COLOR_CLASS.green);
      case 5: return Array(5).fill(COLOR_CLASS.aqua);
      case 6: return Array(6).fill(COLOR_CLASS.purple);
      case 7: return [COLOR_CLASS.red, COLOR_CLASS.orange, COLOR_CLASS.yellow, COLOR_CLASS.green, COLOR_CLASS.aqua, COLOR_CLASS.purple, COLOR_CLASS.lilac];
      case 8: return Array(8).fill(COLOR_CLASS.hotpink);
      case 9: // ★ 薄灰3 → 灰3 → 濃灰3
        return [
          COLOR_CLASS.graylight, COLOR_CLASS.graylight, COLOR_CLASS.graylight,
          COLOR_CLASS.gray,      COLOR_CLASS.gray,      COLOR_CLASS.gray,
          COLOR_CLASS.graydark,  COLOR_CLASS.graydark,  COLOR_CLASS.graydark
        ];
      default: return [];
    }
  }

  /* ========= ユニット生成 ========= */
  function createTwentyUnit(role='left'){
    const d = document.createElement('div');
    d.className = `block twentyu ${role}`;
    d.dataset.kind = 'twentyu'; // 値1（見た目は20まとまり）×20個で20を表現
    return d;
  }
  function createTenUnit(role='left'){
    const d = document.createElement('div');
    d.className = `block tenu ${role}`;
    d.dataset.kind = 'tenu'; // 値1（見た目は10まとまり）×10個で10を表現
    return d;
  }
  function createOneUnit(colorClass, role='left'){
    const d = document.createElement('div');
    d.className = `block one ${colorClass} ${role}`;
    d.dataset.kind = 'one'; // 値1
    return d;
  }

  /**
   * n を「20まとまり（20×1を20個）→10まとまり（10×1を10個）→一桁」へ分解
   * ※ 各要素は値1なので、DOM子要素数の合計＝n
   */
  function renderValue(container, n, role){
    const twenties = Math.floor(n / 20);
    let remain = n % 20;
    for (let i=0; i<twenties; i++){
      for (let j=0; j<20; j++){
        container.appendChild(createTwentyUnit(role));
      }
    }
    const tens = Math.floor(remain / 10);
    remain = remain % 10;
    for (let i=0; i<tens; i++){
      for (let j=0; j<10; j++){
        container.appendChild(createTenUnit(role));
      }
    }
    for (const cls of onesColors(remain)){
      container.appendChild(createOneUnit(cls, role));
    }
  }

  function populate(){
    const a = clamp(parseInt(el.a.value || '0', 10), 0, 99);
    const b = clamp(parseInt(el.b.value || '0', 10), 0, 99);
    el.a.value = a; el.b.value = b;
    clearBlocks();
    renderValue(el.left, a, 'left');
    renderValue(el.right, b, 'right');
    updateEq(a, b, el.op.value, null);
    el.hint.textContent = '「再生」を押すとブロックが動きます。';
    requestAnimationFrame(updateResponsiveSizes);
    requestAnimationFrame(fitToViewport);
  }

  /* ========= 自動縮小（横10列に収める） ========= */
  function updateResponsiveSizes(){
    const wraps = [el.left, el.right, el.result];
    const widths = wraps.map(w => (w && (w.clientWidth || w.getBoundingClientRect().width)) || 0).filter(w => w>0);
    const minW = widths.length ? Math.min(...widths) : Math.max(320, el.workspace.clientWidth);
    let gap = clamp(Math.round(minW * 0.02), 3, 12);
    let bs  = Math.floor((minW - 9 * gap) / 10);
    if (bs < 10){ gap = 2; bs = Math.floor((minW - 9 * gap) / 10); }
    bs = Math.max(10, Math.min(bs, 96));
    document.documentElement.style.setProperty('--gap', `${gap}px`);
    document.documentElement.style.setProperty('--block-size', `${bs}px`);
  }
  window.addEventListener('resize', () => { requestAnimationFrame(updateResponsiveSizes); requestAnimationFrame(fitToViewport); });

  /* ========= アニメ基盤 ========= */
  function flipMove(elm, newParent){
    return new Promise(resolve => {
      const start = elm.getBoundingClientRect();
      newParent.appendChild(elm);
      const end = elm.getBoundingClientRect();
      const dx = start.left - end.left;
      const dy = start.top - end.top;
      elm.style.transition = 'none';
      elm.style.transform = `translate(${dx}px, ${dy}px)`;
      requestAnimationFrame(() => {
        elm.style.transition = `transform ${ms(600)}ms ease`;
        elm.style.transform = 'translate(0,0)';
        const done = () => { elm.removeEventListener('transitionend', done); elm.style.transition=''; resolve(); };
        elm.addEventListener('transitionend', done, { once:true });
      });
    });
  }

  function flyClone(fromEl, toRect){
    return new Promise(resolve => {
      const r1 = fromEl.getBoundingClientRect();
      const clone = fromEl.cloneNode(true);
      clone.classList.add('fly-clone');
      clone.style.width = `${r1.width}px`;
      clone.style.height = `${r1.height}px`;
      clone.style.left = `${r1.left}px`;
      clone.style.top = `${r1.top}px`;
      clone.style.transition = `transform ${ms(500)}ms ease`;
      clone.style.transform = 'translate(0,0)';
      document.body.appendChild(clone);
      requestAnimationFrame(()=>{
        const dx = (toRect.left - r1.left);
        const dy = (toRect.top - r1.top);
        clone.style.transform = `translate(${dx}px, ${dy}px)`;
      });
      clone.addEventListener('transitionend', () => resolve(clone), { once:true });
    });
  }

  function flyAndPoofUnit(fromEl, toEl){
    return new Promise(async resolve => {
      const toRect = toEl.getBoundingClientRect();
      const clone = await flyClone(fromEl, toRect);
      toEl.classList.add('cross');
      clone.classList.add('poof');
      fromEl.remove();
      Audio.pop();
      setTimeout(()=>{
        toEl.classList.add('poof');
        setTimeout(()=>{
          toEl.remove();
          clone.remove();
          resolve();
        }, ms(320));
      }, ms(80));
    });
  }

  /* ========= アニメーション ========= */
  async function animatePlus(a, b){
    el.hint.textContent = 'たしているよ…';
    Audio.whoosh();
    for (const blk of Array.from(el.left.children)){ await flipMove(blk, el.result); }
    for (const blk of Array.from(el.right.children)){ await flipMove(blk, el.result); }
    const n = a + b;
    await new Promise(r=> setTimeout(r, ms(100)));
    el.result.innerHTML = '';
    renderValue(el.result, n, 'result');
    updateEq(a, b, '+', n);
    el.hint.textContent = 'できた！ もとのブロックも見てみよう。';
    updateResponsiveSizes(); fitToViewport();
    restoreSides(a, b);
  }

  async function animateMinus(a, b){
    if (b > a){ el.hint.textContent = '※ 引き算は「数A ≥ 数B」を入力してください。'; return; }
    el.hint.textContent = 'ひいているよ…（右端から消えるよ）';
    for (let i=0; i<b; i++){
      const fromRight = el.right.lastElementChild;
      const targetLeft = el.left.lastElementChild;
      if (!fromRight || !targetLeft) break;
      await flyAndPoofUnit(fromRight, targetLeft);
    }
    for (const blk of Array.from(el.left.children)){ await flipMove(blk, el.result); }
    const n = a - b;
    await new Promise(r=> setTimeout(r, ms(100)));
    el.result.innerHTML = '';
    renderValue(el.result, n, 'result');
    updateEq(a, b, '-', n);
    el.hint.textContent = 'できた！ もとのブロックも見てみよう。';
    updateResponsiveSizes(); fitToViewport();
    restoreSides(a, b);
  }

  function restoreSides(a, b){
    el.left.innerHTML = '';
    el.right.innerHTML = '';
    renderValue(el.left, a, 'left');
    renderValue(el.right, b, 'right');
    updateResponsiveSizes(); fitToViewport();
  }

  /* ========= チャレンジ ========= */
  const QCOUNT = 5;
  const challenge = {
    active:false, list:[], idx:0, correct:0, marks:[], // 'done' / 'fail'
    mode:'plus', level:'easy'
  };

  function buildProgress(){
    el.progress.innerHTML = '';
    for (let i=0; i<QCOUNT; i++){
      const d = document.createElement('div');
      d.className = 'dot' + (challenge.marks[i] ? ' '+challenge.marks[i] : '');
      el.progress.appendChild(d);
    }
    el.score.textContent = `正解 ${challenge.correct}/${QCOUNT}`;
  }

  function problemKey(p){
    if (p.op === '+'){
      const x = Math.min(p.a, p.b), y = Math.max(p.a, p.b);
      return `+:${x}:${y}`;
    }
    return `-:${p.a}:${p.b}`;
  }

  function rInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function rangesFor(level){
    switch(level){
      case 'easy':   return { a:[1,5],  b:[1,5]  };
      case 'normal': return { a:[5,10], b:[1,5]  };
      case 'hard':   return { a:[1,19], b:[1,10] };
      default:       return { a:[1,5],  b:[1,5]  };
    }
  }
  function genProblem(){
    const plus = challenge.mode==='plus' ? true : (challenge.mode==='minus' ? false : Math.random()<0.5);
    const {a:[aMin,aMax], b:[bMin,bMax]} = rangesFor(challenge.level);
    let a, b;
    if (plus){
      a = rInt(aMin, aMax);
      b = rInt(bMin, bMax);
    } else {
      a = rInt(aMin, aMax);
      const bUpper = Math.min(bMax, a);
      const bLower = Math.min(bMin, bUpper);
      b = rInt(bLower, bUpper);
    }
    return {op: plus?'+':'-', a, b};
  }

  function startChallenge(){
    challenge.mode = el.modeSel.value || 'plus';
    challenge.level = el.levelSel.value || 'easy';
    challenge.active = true;
    challenge.idx = 0;
    challenge.correct = 0;
    challenge.marks = Array(QCOUNT).fill('');
    const seen = new Set();
    const list = [];
    let guard = 0;
    const MAX_GUARD = 5000;
    while (list.length < QCOUNT && guard < MAX_GUARD){
      const p = genProblem();
      const key = problemKey(p);
      if (!seen.has(key)){ seen.add(key); list.push(p); }
      guard++;
    }
    challenge.list = list;

    el.basicControls.classList.add('hidden');
    el.ansArea.classList.remove('hidden');
    el.endCh.classList.remove('hidden');
    el.nextQ.classList.add('hidden');
    el.checkMsg.textContent = '';
    el.ansInput.value = '';

    loadChallengeProblem();
    buildProgress();
    updateResponsiveSizes(); fitToViewport();
  }

  function endChallenge(){
    saveDailyStats(1, challenge.correct);
    challenge.active = false;
    el.basicControls.classList.remove('hidden');
    el.ansArea.classList.add('hidden');
    el.endCh.classList.add('hidden');
    el.nextQ.classList.add('hidden');
    el.checkMsg.textContent = '';
    const total = challenge.correct;
    el.hint.textContent = `チャレンジ終了！ 正解 ${total}/${QCOUNT}`;
    if (total >= 3){ showStamp(); }
    updateResponsiveSizes(); fitToViewport();
  }

  function loadChallengeProblem(){
    const p = challenge.list[challenge.idx];
    el.op.value = p.op;
    el.a.value = p.a;
    el.b.value = p.b;
    populate();
    updateEq(p.a, p.b, p.op, null);
    el.ansInput.value = '';
    el.checkMsg.textContent = '';
    el.nextQ.classList.add('hidden');
    el.play.disabled = false;
    if (autoTimer){ clearTimeout(autoTimer); autoTimer = null; }
  }

  /* ========= 祝・サウンド ========= */
  function celebrate(){
    // 正解時のみに呼ばれる（不正解では呼ばない）
    // 紙吹雪（下部中央→上へ扇状）
    const layer = el.celebrate;
    layer.classList.remove('hidden');
    const colors = ['#ef4444','#f59e0b','#facc15','#22c55e','#38bdf8','#a855f7','#e91e63','#9ca3af'];
    const count = 100;
    for (let i=0;i<count;i++){
      const c = document.createElement('div');
      c.className = 'confetti';
      c.style.background = colors[i % colors.length];
      c.style.setProperty('--dx', (Math.random()*80 - 40) + 'vw');
      c.style.animationDuration = (700 + Math.random()*900) + 'ms';
      c.style.animationDelay = (Math.random()*120) + 'ms';
      layer.appendChild(c);
    }
    Audio.chord();
    setTimeout(()=>{ layer.classList.add('hidden'); layer.innerHTML=''; }, 1300);
  }

  const STAMP_EMOJIS = [
    '🍎','🍊','🍋','🍌','🍉','🍇','🍓','🍒','🍑','🍍',
    '🥝','🥭','🍐','🍈','🫐',
    '🐶','🐱','🐭','🐹','🐰','🦊','🐻','🐼','🐨','🐯',
    '🦁','🐮','🐷','🐸','🐵'
  ];
  function showStamp(){
    const e = STAMP_EMOJIS[Math.floor(Math.random()*STAMP_EMOJIS.length)];
    const stamp = document.createElement('div');
    stamp.className = 'stamp';
    stamp.innerHTML = `
      <div class="stamp-card">
        <div class="stamp-emoji">${e}</div>
        <div class="stamp-title">スタンプGET！</div>
        <div class="stamp-sub">よくがんばったね</div>
        <button class="stamp-close">OK</button>
      </div>`;
    document.body.appendChild(stamp);
    const closer = () => { stamp.removeEventListener('click', closer); stamp.remove(); };
    const timer = setTimeout(closer, 3000);
    stamp.addEventListener('click', () => { clearTimeout(timer); closer(); });
  }

  // サウンド（WebAudio）
  const Audio = (()=> {
    let ctx=null, enabled=true;
    function ensure(){
      if (!ctx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return;
        ctx = new AC();
      }
      if (ctx && ctx.state === 'suspended') ctx.resume();
    }
    function setEnabled(on){ enabled = !!on; return enabled; }
    function isOn(){ return !!enabled; }
    function osc(freq=440, dur=0.2, type='sine', vol=0.04){
      if (!enabled) return;
      ensure(); if (!ctx) return;
      const t = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type; o.frequency.value = freq;
      o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(vol, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
      o.start(t); o.stop(t+dur+0.05);
    }
    function chord(){ osc(880, 0.34, 'triangle', 0.06); osc(1174.66, 0.36, 'triangle', 0.05); osc(1567.98, 0.4, 'sine', 0.05); }
    function whoosh(){ osc(220, 0.14, 'sawtooth', 0.02); osc(330, 0.12, 'sine', 0.02); }
    function pop(){
      if (!enabled) return; ensure(); if (!ctx) return;
      const duration = 0.08;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * duration, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++){ const t = i / data.length; data[i] = (Math.random()*2 - 1) * (1 - t); }
      const src = ctx.createBufferSource();
      const g = ctx.createGain(); g.gain.value = 0.07;
      src.buffer = buffer; src.connect(g); g.connect(ctx.destination); src.start();
    }
    return { ensure, chord, whoosh, pop, setEnabled, isOn };
  })();

  el.soundToggle.addEventListener('click', () => {
    Audio.ensure();
    const nowOn = !Audio.isOn();
    Audio.setEnabled(nowOn);
    el.soundToggle.textContent = nowOn ? '🔊 サウンド ON' : '🔇 サウンド OFF';
  });

  // 入力（答え欄：マイナス禁止）
  el.ansInput.addEventListener('keydown', (e) => {
    if (['-','+','e','E'].includes(e.key)) e.preventDefault();
  });
  el.ansInput.addEventListener('input', () => {
    el.ansInput.value = (el.ansInput.value || '').replace(/[^\d]/g,'');
  });
  el.ansInput.addEventListener('wheel', (e)=> e.preventDefault(), { passive:false });

  /* ========= 日別記録 localStorage ========= */
  const STATS_KEY = 'kids-math-stats-v1';
  function todayKey(){ const d=new Date(); return d.toISOString().slice(0,10); }
  function loadStats(){ try{ return JSON.parse(localStorage.getItem(STATS_KEY) || '{}'); }catch(e){ return {}; } }
  function saveStats(obj){ localStorage.setItem(STATS_KEY, JSON.stringify(obj)); }
  function saveDailyStats(challengeCount, correctAdd){
    const key = todayKey();
    const stats = loadStats();
    const cur = stats[key] || { challenges:0, correct:0 };
    cur.challenges += (challengeCount||0);
    cur.correct    += (correctAdd||0);
    stats[key] = cur;
    saveStats(stats);
    updateDailyStatsView();
  }
  function updateDailyStatsView(){
    const key = todayKey();
    const s = loadStats()[key] || {challenges:0, correct:0};
    el.dailyStats.textContent = `今日: チャレンジ${s.challenges}回 / 正解${s.correct}問`;
  }

  /* ========= イベント ========= */
  async function onPlay(){
    if (animating) return;
    const a = clamp(parseInt(el.a.value || '0', 10), 0, 99);
    const b = clamp(parseInt(el.b.value || '0', 10), 0, 99);
    const op = el.op.value;
    populate();
    animating = true;
    setDisabled(true);
    try{
      if (op === '+'){ await animatePlus(a, b); }
      else {
        if (b > a){ el.hint.textContent = '※ 引き算は「数A ≥ 数B」を入力してください。'; }
        else { await animateMinus(a, b); }
      }
    } finally {
      animating = false;
      setDisabled(false);
      if (challenge.active){ el.nextQ.classList.remove('hidden'); }
    }
  }
  function onReset(){ if (animating) return; clearBlocks(); populate(); }
  function onRandom(){
    if (animating) return;
    const op = Math.random() < 0.5 ? '+' : '-';
    let a, b;
    if (op === '+'){ a = Math.floor(Math.random()*21); b = Math.floor(Math.random()*21); }
    else { a = Math.floor(Math.random()*21)+9; b = Math.floor(Math.random()*(a+1)); }
    el.op.value = op; el.a.value = a; el.b.value = b; populate();
  }

  el.play.addEventListener('click', () => { Audio.ensure(); onPlay(); });
  el.reset.addEventListener('click', onReset);
  el.random.addEventListener('click', onRandom);
  [el.a, el.b, el.op].forEach(inp => inp.addEventListener('change', () => { populate(); fitToViewport(); }));
  el.speed.addEventListener('input', () => { speedMul = parseFloat(el.speed.value || '1'); el.speedLabel.textContent = `x${speedMul.toFixed(2).replace(/\.00$/,'')}`; });

  el.startCh.addEventListener('click', () => { Audio.ensure(); startChallenge(); });
  el.endCh.addEventListener('click', () => { if (autoTimer){ clearTimeout(autoTimer); autoTimer=null; } endChallenge(); });
  el.checkBtn.addEventListener('click', () => { Audio.ensure(); checkAnswer(); });
  el.nextQ.addEventListener('click', nextQuestion);
  el.modeSel.addEventListener('change', () => { if (!challenge.active) {/* 設定のみ */} });
  el.levelSel.addEventListener('change', () => { if (!challenge.active) {/* 設定のみ */} });

  // チャレンジ回答チェック & 自動進行
  async function checkAnswer(){
    const p = challenge.list[challenge.idx];
    const n = p.op === '+' ? (p.a + p.b) : (p.a - p.b);
    const user = parseInt(el.ansInput.value || 'NaN', 10);
    if (user === n){
      el.checkMsg.textContent = '⭕ せいかい！';
      el.checkMsg.style.color = '#16a34a';
      if (!challenge.marks[challenge.idx]) challenge.correct++;
      challenge.marks[challenge.idx] = 'done';
      buildProgress();
      // ★ 正解のみ祝エフェクト
      celebrate();
      // ★ 正解でもチャレンジ用の可視化アニメを自動再生
      await onPlay();
      if (!challenge.active) return;
      // ★ 正解時のみ3秒後に自動遷移
      if (challenge.idx < QCOUNT - 1){ autoTimer = setTimeout(()=> nextQuestion(), 3000); }
      else { autoTimer = setTimeout(()=> endChallenge(), 3000); }
    } else {
      el.checkMsg.textContent = '❌ ちがうよ';
      el.checkMsg.style.color = '#ef4444';
      challenge.marks[challenge.idx] = 'fail';
      buildProgress();
      // ★ 不正解でも可視化アニメを自動再生（学習フィードバック）
      await onPlay();
      // 不正解時は自動遷移しない（再挑戦できる）
    }
  }
  function nextQuestion(){
    if (autoTimer){ clearTimeout(autoTimer); autoTimer=null; }
    if (challenge.idx < QCOUNT - 1){
      challenge.idx++;
      loadChallengeProblem();
      buildProgress();
      fitToViewport();
    } else {
      endChallenge();
    }
  }

  // 初期化
  el.modeSel.value = 'plus'; challenge.mode = 'plus';
  el.levelSel.value = 'easy'; challenge.level = 'easy';
  populate();
  updateDailyStatsView();
  fitToViewport();

  /* ========= PWA: HTTPS or localhost なら Service Worker登録（任意） ========= */
  if ('serviceWorker' in navigator &&
      (location.protocol === 'https:' || location.hostname === 'localhost')) {
    // sw.js を用意した場合のみ有効（なくても動作可）
    navigator.serviceWorker.register('./sw.js').catch(()=>{});
  }
})();
</script>
</body>
